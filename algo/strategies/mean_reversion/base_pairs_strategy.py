import backtrader as bt
from algo.cointegration.augmented_dickey_fuller import adf_stationarity
from algo.cointegration.engle_granger import engle_granger_bidirectional
from algo.cointegration.johansen import johansen_95


class PairsTradingStrategy(bt.Strategy):

    def __init__(self, * args, **kwargs):
        print(f"Initial Position:\n {self.position}")

        # Tracking
        self.order_buy = None
        self.order_sell = None
        self.order_close0 = None
        self.order_close1 = None
        self.order_buy_roll = None
        self.order_sell_roll = None

    def next(self):
        raise NotImplementedError

    @property
    def in_market(self) -> bool:
        return self.is_long or self.is_short

    @property
    def is_long(self) -> bool:
        return self.positionsbyname[self.asset0].size > 0.0 and self.positionsbyname[self.asset1].size < 0.0

    @property
    def is_short(self) -> bool:
        return self.positionsbyname[self.asset0].size < 0.0 and self.positionsbyname[self.asset1].size > 0.0

    @property
    def is_order_pending(self) -> bool:
        """
        Returns: True if an order is open to enter positions by buying or selling asset 0 or asset 1.
        """
        return self.order_buy is not None or self.order_sell is not None or \
               self.order_buy_roll is not None or self.order_sell_roll is not None

    @property
    def is_rolling(self) -> bool:
        return self.roll_long or self.roll_short or \
               self.order_buy_roll is not None or self.order_sell_roll is not None

    @property
    def is_exit_order_pending(self) -> bool:
        """
        Returns: True if an order is open to exit positions by buying or selling asset 0 or asset 1.
        """
        return self.order_close0 is not None or self.order_close1 is not None

    def log(self, message: str, order) -> None:
        e = order.executed
        date_time = bt.num2date(e.dt)
        cash = self.broker.get_cash()
        pf_value = self.broker.fundshares * self.broker.fundvalue

        log_output = f"{date_time.isoformat()} {message}"
        log_output += f" Price: {e.price:.2f}, "
        log_output += f"Size: {e.size}, "
        log_output += f"Cost: {e.value:.2f}, "
        log_output += f"Commission: {e.comm:.2f}, "
        log_output += f"Cash: {cash:.2f}, "
        log_output += f"Pf_value: {pf_value:.2f}"

        if order.executed.margin is not None:
            log_output += f", Margin: {e.margin:.2f}"

        print(log_output)

    def notify_trade(self, trade):
        trade_msg = f"{bt.num2date(trade.dtopen)} global_step = {self.global_step} Trade ID: {trade.ref} "
        trade_msg += "LONG" if trade.long else "SHORT"
        trade_msg += " OPENED " if trade.isopen else " CLOSED "
        trade_msg += f"size = {trade.size}, price = {trade.price:.2f}, value = {trade.value:.2f}, "
        trade_msg += f"PNL = {trade.pnl:.3f}, PNL_commission = {trade.pnlcomm:.3f}"
        print(trade_msg)

        if not trade.isopen:
            print(f"\t{bt.num2date(trade.dtclose)} Close - Market prices: p0 = {self.S0[-1]:.2f}, p1 = {self.S1[-1]:.2f}")


def pretrade_checks(S0, S1, spread, verbose=False, test_johansen=False, test_asset_unit_roots=False):
    results = {
        # Test for stationarity in the actual spread series generated by the OU Model.
        "adf_c": adf_stationarity(spread, trend="c"),
        # Test for cointegration in the underlying asset price series.
        "engle_granger_c": engle_granger_bidirectional(S0, S1, trend="c"),
    }

    if test_johansen:
        results.update({"johansen_95": johansen_95(S0, S1)})

    if test_asset_unit_roots:
        results.update({
            "adf_c_S0": adf_stationarity(S0, trend="c"),
            "adf_c_S1": adf_stationarity(S1, trend="c"),
        })

    if verbose:
        print(results)

    return results["adf_c"]
